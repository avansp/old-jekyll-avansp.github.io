---
output: html_document
---

```{r,echo=FALSE}
rm(list=ls())
set.seed(83722)
```

The generic Simulated Annealing algorithm, adapted from [Yong Wang](https://www.stat.auckland.ac.nz/~yongwang/)'s slide:
```{r, echo=TRUE}
SA <- function( init,       # the initial configuration
                cost.fun,   # the cost or target function to maximize 
                            # (WARNING: set negative yourself for minimization !!)
                walk.fun,   # the random walk or proposal function
                cool.fun = function(n) 0.995^(1:n) * 1000,    # cooling schedule
                n = 5000,   # number of iterations
                ... )       # any arguments given to the walk.fun function
{
  # The output sa is a list, containing:
  #   chain : matrix of Markov chain
  #   cost : costs from each chain
  S <- list(chain=matrix(nrow=n+1, ncol=length(init)), cost=numeric(n+1))
  S$chain[1,] <- init
  S$cost[1] <- cost.fun(init)
  
  tmp <- cool.fun(n)
  for( i in 2:(n+1) )
  {
    z = walk.fun(S$chain[(i-1),], ...)
    cost.z <- cost.fun(z)
    delta.h <- cost.z - S$cost[i-1]
    if( runif(1) < min( exp(delta.h / tmp[i-1]), 1 ) ) {
      S$chain[i,] <- z
      S$cost[i] <- cost.z
    } else {  # stay the same (rejected)
      S$chain[i,] <- S$chain[i-1,]
      S$cost[i] <- S$cost[i-1]
    }
    
    if( i%%1000 == 0 )
      cat(sprintf("Passed iteration %d\n", i))
  }
  
  # the output
  S
}
```


Let $k$ random points representing cities generated from uniform random distributions on $(0,1)^2$. Distances between cities are measured using the Euclidean distance.
```{r,echo=TRUE, fig.width=5, fig.height=5}
k <- 50             # SET here the number of cities
cities <- cbind(runif(k,0,1), runif(k,0,1))
```

Calculate the distance matrix:
```{r,echo=TRUE, results='asis'}
dist.cities <- dist(cities, method='euclidean')
```

Given a tour from $c = (c_1, c_2, \ldots, c_k, c_1)$, define the total cost as the sum:
```{r,echo=TRUE}
cost.tour <- function(tour,  # give the tour from c(1) to c(k)
                      d)     # the distance matrix
{
  if( is.null(k <- attr(d,"Size")) ) stop('d must be a distance matrix')
  if( length(setdiff(unique(tour), 1:k)) > 0 ) stop('invalid tour')
  tour.xy <- cbind(tour, c(tour[-1], tour[1]))
  sum(as.matrix(d)[tour.xy])
}
```

Let's check it with initial random tour:
```{r,echo=TRUE, fig.width=5, fig.height=5}
plot.tour <- function(tour, cities, d, ...)
{
  plot(cities, pch=16, asp=1, xlab='x', ylab='y',
       main = sprintf("D = %.2f", cost.tour(tour, d)))
  lines( cities[c(tour, tour[1]),], col="red" )
}
init.tour <- sample(1:k)
plot.tour(init.tour, cities, dist.cities)
```

The Simulated Annealing solution to the TSP is performed by choosing randomly two cities $i$ and $j$. The block between $c_i$ to $c_j$ is then reversed. For example, if the current tour for $i<j$ is

$c = (c_1,\ldots,c_{i-1},c_i,c_{i+1},\ldots,c_{j-1},c_j,c_{j+1},\ldots,c_k)$

then the next tour is

$c = (c_j,c_{j-1},\ldots,c_{i+1},c_{i},c_{j+1},\ldots,c_{k},c_1,\ldots,c_{i-1}) = (c_1,\ldots,c_{i-1},c_j,c_{j-1},\ldots,c_{i+1},c_{i},c_{j+1},\ldots,c_{k})$
  
For $i>j$, if the current tour is

$c = (c_1,\ldots,c_{j-1},c_j,c_{j+1},\ldots,c_{i-1},c_i,c_{i+1},\ldots,c_k)$

the solution is

$c = (c_j,c_{j-1},\ldots,c_1,c_k,\ldots,c_{i+1},c_i,c_{j+1},\ldots,c_{i-1}) = (c_1,c_k,\ldots,c_{i+1},c_i,c_{j+1},\ldots,c_{i-1},c_j,c_{j-1},\ldots,c_2)$
  
*Note that first the $j$th city is brought at the first city in the tour in the first solution. The second solution is just to ensure that the first city to start is always at $c_1$ though the cost of TSP will be identical no matter where you start iff the route is equivalent.*

This is going to be the `walk.fun` function:
```{r, echo=TRUE}
walk.tsp <- function(tour)
{
  k <- length(tour)
  
  ## get any two distinct cities
  ij <- sample(k, size=2, replace=FALSE)
  next.tour <- tour
  next.tour[c(ij[1]:ij[2])] <- rev(next.tour[c(ij[1]:ij[2])])
  next.tour
}
```

Let's try the SA algorithm (**don't forget to invert the cost!!**):
```{r,echo=TRUE}
tsp.basic <- SA(init.tour, 
                cost.fun = function(x) -cost.tour(x,dist.cities), 
                walk.fun = walk.tsp,
                n = 10000)
```

The cost plot
```{r,echo=TRUE}
plot(-tsp.basic$cost, type='l', xlab="Iteration", ylab="Traveling Cost")
```

The four representative routes:
```{r,echo=TRUE, fig.width=10, fig.height=10}
par(mfrow=c(2,2))
iter <- seq(1,length(tsp.basic$cost),len=4)
plot.tour(tsp.basic$chain[iter[1],], cities, dist.cities)
plot.tour(tsp.basic$chain[iter[2],], cities, dist.cities)
plot.tour(tsp.basic$chain[iter[3],], cities, dist.cities)
plot.tour(tsp.basic$chain[iter[4],], cities, dist.cities)
```

